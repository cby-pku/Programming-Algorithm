////////////////////////////////4.1完成复习
//////////////////////////////
////////////////////////////////////#include<iostream>
////////////////////////////////////#include<stdio.h>
////////////////////////////////////using namespace std;
////////////////////////////////////class Complex {
////////////////////////////////////public:
////////////////////////////////////	double real, imag;
////////////////////////////////////	void print() { cout << real << "," << imag; }
////////////////////////////////////	Complex(double r,double i):real(r),imag(i){}
////////////////////////////////////	Complex AddOne() {
////////////////////////////////////		this->real++;
////////////////////////////////////		this->print();
////////////////////////////////////		return *this;
////////////////////////////////////	}
////////////////////////////////////};
////////////////////////////////////int main() {
////////////////////////////////////	Complex c1(1, 1), c2(0, 0);
////////////////////////////////////	c2 = c1.AddOne();
////////////////////////////////////	return 0;
////////////////////////////////////}
//////////////////////////////////
////////////////////////////////////-----虚函数和多态----
///////////////////////////////////*
//////////////////////////////////#include<iostream>
//////////////////////////////////#include<stdio.h>
//////////////////////////////////using namespace std;
//////////////////////////////////class A {
//////////////////////////////////public:
//////////////////////////////////	virtual void print(){
//////////////////////////////////		cout << "A::Print" << endl;
//////////////////////////////////	}
//////////////////////////////////};
//////////////////////////////////class B:public A {
//////////////////////////////////public:
//////////////////////////////////	virtual void print() {
//////////////////////////////////		cout << "B::Print" << endl;
//////////////////////////////////	}
//////////////////////////////////};
//////////////////////////////////class D :public A {
//////////////////////////////////public:
//////////////////////////////////	virtual void print() {
//////////////////////////////////		cout << "D::Print" << endl;
//////////////////////////////////	}
//////////////////////////////////};
//////////////////////////////////class E :public B {
//////////////////////////////////	virtual void print() {
//////////////////////////////////		cout << "E::Print" << endl;
//////////////////////////////////	}
//////////////////////////////////};
//////////////////////////////////int main() {
//////////////////////////////////	A a; B b; E e; D d;
//////////////////////////////////	A*pa = &a;
//////////////////////////////////	B*pb = &b; D*pd = &d;
//////////////////////////////////	E*pe = &e;
//////////////////////////////////	pa->print();
//////////////////////////////////	pa = pb;
//////////////////////////////////	pa->print();
//////////////////////////////////	pa = pd;
//////////////////////////////////	pa->print();
//////////////////////////////////	pa = pe;
//////////////////////////////////	pa->print();
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////}*/
////////////////////////////////////----多态实现游戏程序
//////////////////////////////////#include<iostream>
//////////////////////////////////#include<stdio.h>
//////////////////////////////////using namespace std;
//////////////////////////////////class CCreature {
//////////////////////////////////protected:
//////////////////////////////////	int m_nLifeValue;
//////////////////////////////////	int m_nPower;
//////////////////////////////////public:
//////////////////////////////////	virtual void Attack(CCreature*pCreature) {}
//////////////////////////////////	virtual void Hurted(int nPower){}
//////////////////////////////////	virtual void FightBack(CCreature*pCreature){}
//////////////////////////////////};//从这里派生出来的也具有这样的特点
//////////////////////////////////class  CDragon :public CCreature {
//////////////////////////////////public:
//////////////////////////////////	virtual void Attack(CCreature*pCreature) {}
//////////////////////////////////	virtual void Hurted(int nPower){}
//////////////////////////////////	virtual void FightBack(CCreature*pCreature){}
//////////////////////////////////};
//////////////////////////////////void CDragon::Attack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower);
//////////////////////////////////	p->FightBack(this);
//////////////////////////////////}
//////////////////////////////////void CDragon::Hurted(int nPower) {
//////////////////////////////////	m_nLifeValue -= nPower;
//////////////////////////////////}
//////////////////////////////////void CDragon::FightBack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower / 2);//反弹一半伤害
//////////////////////////////////}
//////////////////////////////////
//////////////////////////////////class  CWolf :public CCreature {
//////////////////////////////////public:
//////////////////////////////////	virtual void Attack(CCreature*pCreature) {}
//////////////////////////////////	virtual void Hurted(int nPower) {}
//////////////////////////////////	virtual void FightBack(CCreature*pCreature) {}
//////////////////////////////////};
//////////////////////////////////void CWolf::Attack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower);
//////////////////////////////////	p->FightBack(this);
//////////////////////////////////}
//////////////////////////////////void CWolf::Hurted(int nPower) {
//////////////////////////////////	m_nLifeValue -= nPower;
//////////////////////////////////}
//////////////////////////////////void CWolf::FightBack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower / 2);//反弹一半伤害
//////////////////////////////////}
//////////////////////////////////class  CGhost :public CCreature {
//////////////////////////////////public:
//////////////////////////////////	virtual void Attack(CCreature*pCreature) {}
//////////////////////////////////	virtual void Hurted(int nPower) {}
//////////////////////////////////	virtual void FightBack(CCreature*pCreature) {}
//////////////////////////////////};
//////////////////////////////////void CGhost::Attack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower);
//////////////////////////////////	p->FightBack(this);
//////////////////////////////////}
//////////////////////////////////void CGhost::Hurted(int nPower) {
//////////////////////////////////	m_nLifeValue -= nPower;
//////////////////////////////////}
//////////////////////////////////void CGhost::FightBack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower / 2);//反弹一半伤害
//////////////////////////////////}
//////////////////////////////////
//////////////////////////////////class CThurderBird :public CCreature {
//////////////////////////////////public:
//////////////////////////////////	virtual void Attack(CCreature*pCreature) {}
//////////////////////////////////	virtual void Hurted(int nPower) {}
//////////////////////////////////	virtual void FightBack(CCreature*pCreature) {}
//////////////////////////////////};
//////////////////////////////////void CThurderBird::Attack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower);
//////////////////////////////////	p->FightBack(this);
//////////////////////////////////}
//////////////////////////////////void CThurderBird::Hurted(int nPower) {
//////////////////////////////////	m_nLifeValue -= nPower;
//////////////////////////////////}
//////////////////////////////////void CThurderBird::FightBack(CCreature*p) {
//////////////////////////////////	p->Hurted(m_nPower / 2);//反弹一半伤害
//////////////////////////////////}
//////////////////////////////////int main() {
//////////////////////////////////	CDragon Dragon; CWolf Wolf; CGhost Ghost;
//////////////////////////////////	CThurderBird Bird;
//////////////////////////////////	Dragon.Attack(&Wolf);
//////////////////////////////////	Dragon.Attack(&Ghost);
//////////////////////////////////	Dragon.Attack(&Bird);//不断调用，实现对类对象的打击
//////////////////////////////////}
////////////////////////////////
//////////////////////////////////几何形体处理程序
////////////////////////////////#include<iostream>
////////////////////////////////#include<stdio.h>
////////////////////////////////using namespace std;
////////////////////////////////
////////////////////////////////class CShape {
////////////////////////////////public:
////////////////////////////////	virtual double Area() = 0;//纯虚函数
////////////////////////////////	virtual void PrintInfo() = 0;
////////////////////////////////};
////////////////////////////////
////////////////////////////////class CRectangle :public CShape {
////////////////////////////////public:
////////////////////////////////	int w, h;
////////////////////////////////	virtual double Area();
////////////////////////////////	virtual void PrintInfo();
////////////////////////////////};
////////////////////////////////class CCircle :public CShape {
////////////////////////////////public:
////////////////////////////////	int r;
////////////////////////////////	virtual double Area();
////////////////////////////////	virtual void PrintInfo();
////////////////////////////////};
////////////////////////////////class CTriangle :public CShape {
////////////////////////////////public:
////////////////////////////////	int a, b, c;
////////////////////////////////	virtual double Area();
////////////////////////////////	virtual void PrintInfo();
////////////////////////////////};
////////////////////////////////CShape*pShapes[100];
////////////////////////////////int MyCompare(const void*s1, const void *s2) {
////////////////////////////////	double a1, a2;
////////////////////////////////	CShape**p1; CShape **p2;//s1,s2是void*，不可写"*s1"来取得s1指向的内容,因为是void类型，所以编译器不知道s1大小是多少，必须强制转化用多态
////////////////////////////////	p1 = (CShape**)s1;//s1,s2指向pShapes数组中的元素，数组元素类型是CShape*
////////////////////////////////	p2 = (CShape**)s2;//p1,p2都是指向指针的指针，类型为CShape**
////////////////////////////////	a1 = (*p1)->Area();
////////////////////////////////	a2 = (*p2)->Area();
////////////////////////////////	if (a1 < a2) {
////////////////////////////////		return -1;
////////////////////////////////	}
////////////////////////////////	else if (a1 > a2) {
////////////////////////////////		return 1;
////////////////////////////////	}
////////////////////////////////	else return 0;
////////////////////////////////}
////////////////////////////////int main() {
////////////////////////////////	int i; int n;
////////////////////////////////	CRectangle *pr; CCircle *pc; CTriangle *pt;
////////////////////////////////	cin >> n;
////////////////////////////////	for (i = 0; i < n; i++) {
////////////////////////////////		char c;
////////////////////////////////		cin >> c;
////////////////////////////////		switch (c)
////////////////////////////////		{
////////////////////////////////		case 'R':pr = new CRectangle();
////////////////////////////////			cin >> pr->w >> pr->h;
////////////////////////////////			pShapes[i] = pr;
////////////////////////////////			break;
////////////////////////////////		case 'C':pc = new CCircle();
////////////////////////////////			cin >> pc->r;
////////////////////////////////			pShapes[i] = pc;
////////////////////////////////			break;
////////////////////////////////		case 'T':pt = new CTriangle();
////////////////////////////////			cin >> pt->a >> pt->b >> pt->c;
////////////////////////////////			pShapes[i] = pt;
////////////////////////////////			break;
////////////////////////////////		default:
////////////////////////////////			break;
////////////////////////////////		}
////////////////////////////////	}
////////////////////////////////	qsort(pShapes, n, sizeof(CShape*), MyCompare);//肯定是要返回这个指针数组的大小，注意这里的理解
////////////////////////////////	for (i = 0; i < n; i++)
////////////////////////////////		pShapes[i]->PrintInfo();
////////////////////////////////	return 0;
////////////////////////////////}
////////////////////////////////
////////////////////////////////double CRectangle::Area()
////////////////////////////////{
////////////////////////////////	return w * h;
////////////////////////////////}
////////////////////////////////
////////////////////////////////void CRectangle::PrintInfo()
////////////////////////////////{
////////////////////////////////	cout << "Rectangle:" << Area() << endl;
////////////////////////////////}
////////////////////////////////
////////////////////////////////double CCircle::Area()
////////////////////////////////{
////////////////////////////////	return 3.14*r*r;
////////////////////////////////
////////////////////////////////}
////////////////////////////////
////////////////////////////////void CCircle::PrintInfo()
////////////////////////////////{
////////////////////////////////	cout << "Circle:" << Area() << endl;
////////////////////////////////}
////////////////////////////////
////////////////////////////////double CTriangle::Area()
////////////////////////////////{
////////////////////////////////	double p = (a + b + c) / 2.0;
////////////////////////////////	return sqrt(p*(p - a)*(p - b)*(p - c));
////////////////////////////////}
////////////////////////////////
////////////////////////////////void CTriangle::PrintInfo()
////////////////////////////////{
////////////////////////////////	cout << "Triangle:" << Area() << endl;
////////////////////////////////}
//////////////////////////////
////////////////////////////////STL自学
////////////////////////////////关联容器
////////////////////////////////pair模板
////////////////////////////////template<class T1,class T2>
////////////////////////////////struct  pair
////////////////////////////////{
////////////////////////////////	T1 first;
////////////////////////////////	T2 second;
////////////////////////////////	pair():first(),second(){}
////////////////////////////////	pair(const T1&a,const T2&b):first(a),second(b){}
////////////////////////////////	//模板之间的互相转化
////////////////////////////////	template<class U1, class U2>
////////////////////////////////	pair(const pair<U1,U2>&p):first(p.first),second(p.second){}
////////////////////////////////};
//////////////////////////////#include<iostream>
//////////////////////////////#include<vector>
//////////////////////////////#include<list>
//////////////////////////////#include<algorithm>
//////////////////////////////using namespace std;
////////////////////////////////template<class Init, class T>
////////////////////////////////Init find(Init first, Init last, const T&val);
//////////////////////////////
//////////////////////////////int main() {
//////////////////////////////	vector<int> v(100);
//////////////////////////////	int i;
//////////////////////////////	for (i = 0; i < v.size(); i++) {
//////////////////////////////		cout << v[i];
//////////////////////////////	}
//////////////////////////////	vector<int>::const_iterator ii;
//////////////////////////////	for (ii = v.begin(); ii != v.end(); ii++) {
//////////////////////////////		cout << *ii;
//////////////////////////////	}
//////////////////////////////	for (ii = v.begin(); ii < v.end(); ii++) {
//////////////////////////////		cout << *ii;//因为ii本质上还是一个指针，所以要解引用
//////////////////////////////	}
//////////////////////////////	//遍历list
//////////////////////////////	list<int>v;
//////////////////////////////	list<int>::const_iterator ii;
//////////////////////////////	for (ii = v.begin(); ii != v.end(); ii++) {
//////////////////////////////		cout << *ii;
//////////////////////////////	}
//////////////////////////////	//算法
//////////////////////////////	int array[10] = { 10,20,30,40 };
//////////////////////////////	vector<int> s;
//////////////////////////////	s.push_back(1); s.push_back(2);
//////////////////////////////	s.push_back(3); s.push_back(4);
//////////////////////////////	vector<int>::iterator p;
//////////////////////////////	p = find(v.begin(), v.end(), 3);
//////////////////////////////	if (p != v.end())
//////////////////////////////		cout << *p << endl;
//////////////////////////////	int *pp = find(array, array + 4, 20);//相当于找到后用这个迭代器（指针）因为array返回的是int类型指针去初始化这个指针
//////////////////////////////
//////////////////////////////}
//////////////////////////////#include<iostream>
//////////////////////////////#include<vector>
//////////////////////////////using namespace std;
//////////////////////////////int main() {
//////////////////////////////	int i;
//////////////////////////////	int a[5] = { 1,2,3,4,5 };
//////////////////////////////	vector<int> v(5);
//////////////////////////////	cout << v.end() - v.begin() << endl;//地址作差，减出来是容器大小和长度
//////////////////////////////	for (i = 0; i < v.size(); i++) {
//////////////////////////////		v[i] = i;
//////////////////////////////	}
//////////////////////////////	v.at(4) = 100;
//////////////////////////////	for (i = 0; i < v.size(); i++) {
//////////////////////////////		cout << v[i] << ",";
//////////////////////////////	}
//////////////////////////////	cout << endl;
//////////////////////////////	vector<int>v2(a, a + 5);
//////////////////////////////	v2.insert(v2.begin() + 2, 13);
//////////////////////////////	for (i = 0; i < v2.size(); i++) {
//////////////////////////////		cout << v2.at(i) << ",";
//////////////////////////////	}
//////////////////////////////}
////////////////////////////////二维动态数组
//////////////////////////////#include<iostream>
//////////////////////////////#include<vector>
//////////////////////////////using namespace std;
//////////////////////////////int main() {
//////////////////////////////	vector<vector<int>>v(3);
//////////////////////////////	for (int i = 0; i < v.size(); ++i) {
//////////////////////////////		for (int j = 0; j < 4; ++j) {
//////////////////////////////			v[i].push_back(j);
//////////////////////////////		}
//////////////////////////////	}
//////////////////////////////	for (int i = 0; i < v.size(); ++i) {
//////////////////////////////		for (int j = 0; j < v[i].size(); ++j) {
//////////////////////////////			cout << v[i][j] << " ";
//////////////////////////////		}
//////////////////////////////		cout << endl;
//////////////////////////////	}return 0;
//////////////////////////////}
//////////////////////////////#include<iostream>
//////////////////////////////#include<list>
//////////////////////////////using namespace std;
//////////////////////////////int main() {
//////////////////////////////	int w = 4;
//////////////////////////////	char string[10];
//////////////////////////////	cin.width(5);
//////////////////////////////	while (cin >> string) {
//////////////////////////////		cout.width(w++);
//////////////////////////////		cout << string << endl;
//////////////////////////////		cin.width(5);
//////////////////////////////	}
//////////////////////////////
//////////////////////////////}
////////////////////////////#include<list>
////////////////////////////#include<iostream>
////////////////////////////#include<algorithm>
////////////////////////////using namespace std;
////////////////////////////class A {
////////////////////////////private:
////////////////////////////	int n;
////////////////////////////public:
////////////////////////////	A(int n_) :n(n_) {};
////////////////////////////	friend bool operator<(const A&a1, const A&a2);
////////////////////////////	friend bool operator==(const A&a1, const A&a2);
////////////////////////////	friend ostream&operator<<(ostream&o, const A&a);
////////////////////////////	//因为是全局重载，要保证它可以访问到A对象的私有成员
////////////////////////////};
////////////////////////////bool operator<(const A&a1, const A&a2) {
////////////////////////////	return a1.n < a2.n;
////////////////////////////}
////////////////////////////bool operator==(const A&a1, const A&a2) {
////////////////////////////	return a1.n == a2.n;
////////////////////////////}
////////////////////////////ostream&operator<<(ostream&o, const A&a) {
////////////////////////////	o << a.n;
//////////////////////////////	return o;
//////////////////////////////}
//////////////////////////////template<class T>
//////////////////////////////void PrintList(const list<T>&lst) {//把模板传下去
//////////////////////////////	int tmp = lst.size();
//////////////////////////////	if (tmp > 0) {
//////////////////////////////		typename list<T>::const_iterator i;
//////////////////////////////		i = lst.begin();
//////////////////////////////		for (i = lst.begin(); i != lst.end(); i++)
//////////////////////////////			cout << *i << ",";
//////////////////////////////	}
//////////////////////////////}
////////////////////////////#include<iostream>
////////////////////////////#include<vector>
////////////////////////////#include<algorithm>
////////////////////////////#include<numeric>
////////////////////////////#include<functional>
////////////////////////////using namespace std;
////////////////////////////int sumSquares(int total, int value) {//虽然是用int调用，相当于返回的时候自动解引用了，注意accumulate的实现
////////////////////////////	//在accumulate中进行解引用
////////////////////////////	return total + value * value;
////////////////////////////}
////////////////////////////template<class T>
////////////////////////////void PrintInterval(T first, T last) {
////////////////////////////	//输出区间[first,last)中的元素
////////////////////////////	for (; first != last; ++first) {
////////////////////////////		cout << *first << " ";
////////////////////////////	}
////////////////////////////	cout << endl;
////////////////////////////}
////////////////////////////template<class T>
////////////////////////////class SumPowers {
////////////////////////////private:
////////////////////////////	int power;
////////////////////////////public:
////////////////////////////	SumPowers(int p):power(p){}
////////////////////////////	const T operator()(const T&total, const T&value) {
////////////////////////////		T v = value;
////////////////////////////		for (int i = 0; i < power - 1; ++i) {
////////////////////////////			v = v * value;
////////////////////////////		}
////////////////////////////		return total + v;
////////////////////////////	}
////////////////////////////};
////////////////////////////
////////////////////////////int main() {
////////////////////////////	const int SIZE = 10;
////////////////////////////	int a1[] = { 1,2,3,4,5,6,7,8,9,10 };
////////////////////////////	vector<int> v(a1, a1 + SIZE);
////////////////////////////	cout << "1)"; PrintInterval(v.begin(), v.end());
////////////////////////////	int result = accumulate(v.begin(), v.end(), 0, sumSquares);
////////////////////////////	//0是初始值
////////////////////////////	cout << "2)平方和" << result << endl;
////////////////////////////	result = accumulate(v.begin(), v.end(), 0,SumPowers<int>(3));
////////////////////////////	cout << "3)立方和" << result << endl;
////////////////////////////	result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(4));//临时对象，局部性很好
////////////////////////////	cout << "4)4次方和" << result;
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////#include<list>
//////////////////////////#include<iostream>
//////////////////////////using namespace std;
//////////////////////////class MyLess {
//////////////////////////public:
//////////////////////////	bool operator()(const int &c1, const int &c2) {
//////////////////////////		return (c1 % 10) < (c2 % 10);
//////////////////////////	}
//////////////////////////};
//////////////////////////template<class T>
//////////////////////////void Print(T first, T last) {
//////////////////////////	for (; first != last; ++first) {
//////////////////////////		cout << *first << ",";
//////////////////////////	}
//////////////////////////}
//////////////////////////int main() {
//////////////////////////	const int SIZE = 5;
//////////////////////////	int a[SIZE] = { 5,21,14,2,3 };
//////////////////////////	list<int>lst(a, a + SIZE);
//////////////////////////	lst.sort(MyLess());
//////////////////////////	Print(lst.begin(), lst.end());
//////////////////////////	cout << endl;
//////////////////////////	lst.sort(greater<int>());
//////////////////////////	Print(lst.begin(), lst.end());
//////////////////////////	cout << endl; return 0;
//////////////////////////}
//////////////////////////pair模板
////////////////////////template<class _T1,class _T2>
////////////////////////struct pair
////////////////////////{
////////////////////////	typedef _T1 first_type;
////////////////////////	typedef _T2 second_type;
////////////////////////	_T1 first;
////////////////////////	_T2 second;
////////////////////////	pair() :first(), second() {};
////////////////////////	pair(const _T1&_a, const _T2&_b) :first(_a), second(_b) {};
////////////////////////	template<class _U1,class _U2>//这是复制构造函数
////////////////////////	pair(const pair<_U1, _U2>&_p) :first(_p.first), second(_p.second) {};
////////////////////////
////////////////////////};
//////////////////////#include<iostream>
//////////////////////#include<map>
//////////////////////using namespace std;
//////////////////////int main() {
//////////////////////	//typedef multimap<int, double, less<int>>mmid;//示例化一个类,用小于号比大小
//////////////////////	//mmid pairs;
//////////////////////	//cout << "1)" << pairs.count(15) << endl;
//////////////////////	//pairs.insert(mmid::value_type(15, 2.7));
//////////////////////	//pairs.insert(mmid::value_type(15, 99.3));
//////////////////////	//cout << "2)" << pairs.count(15) << endl;
//////////////////////	//pairs.insert(mmid::value_type(30, 111.11));
//////////////////////	//pairs.insert(mmid::value_type(10, 22.22));
//////////////////////	//for (mmid::const_iterator i = pairs.begin();
//////////////////////	//	i != pairs.end(); ++i) {
//////////////////////	//	cout << "(" << i->first << "," << i->second << ")" << ",";
//////////////////////	//}
//////////////////////	multimap<string, greater<string>>mp;
//////////////////////	
//////////////////////}
////////////////////#include<iostream>
////////////////////#include<map>
////////////////////#include<string>
////////////////////using namespace std;
//////////////////////分数是可以重复，要使用multimap允许关键字重复，而且要用分数做关键字
////////////////////class CStudent {
////////////////////public:
////////////////////	struct CInfo {
////////////////////		int id;
////////////////////		string name;
////////////////////	};
////////////////////	int score;
////////////////////	CInfo info;
////////////////////};
////////////////////typedef multimap<int, CStudent::CInfo>MAP_STD;
////////////////////int main() {
////////////////////	MAP_STD mp;
////////////////////	CStudent st;
////////////////////	string cmd;
////////////////////	while (cin >> cmd) {
////////////////////		if (cmd == "Add") {
////////////////////			cin >> st.info.name >> st.info.id >> st.score;
////////////////////			mp.insert(MAP_STD::value_type(st.score,st.info));
////////////////////		}
////////////////////		else if (cmd == "Query") {
////////////////////			int score;
////////////////////			cin >> score;
////////////////////			MAP_STD::iterator p = mp.lower_bound(score);
////////////////////			if (p != mp.begin()) {
////////////////////				--p;
////////////////////				score = p->first;
////////////////////				MAP_STD::iterator maxp = p;//记录下对应的位置，还要考这个迭代器输出score和info呢
////////////////////				int maxld = p->second.id;//接下来是循环，倒着往前走，比那里所有和score相同的，更新最大id
////////////////////				for (; p != mp.begin() && p->first == score; --p) {
////////////////////					if (p->second.id > maxld) {
////////////////////						maxp = p;
////////////////////						maxld = p->second.id;
////////////////////					}
////////////////////				}
////////////////////				if (p->first == score) {//处理最后一种情况，对于一开始的那个元素begin也要判断
////////////////////					if (p->second.id > maxld) {
////////////////////						maxp = p;
////////////////////						maxld = p->second.id;
////////////////////					}
////////////////////				}
////////////////////				cout << maxp->second.name << " " << maxp->second.id << " " << maxp->first << endl;
////////////////////			}
////////////////////			else {
////////////////////				cout << "Nobody" << endl;
////////////////////			}
////////////////////		}
////////////////////	}
////////////////////}
//////////////////#include<iostream>
//////////////////#include<queue>
//////////////////using namespace std;
//////////////////int main() {
//////////////////	priority_queue<double>priorities;
//////////////////	priorities.push(3.2);
//////////////////	priorities.push(9.8);
//////////////////	priorities.push(5.4);
//////////////////	while (!priorities.empty()) {
//////////////////		cout << priorities.top() << " ";
//////////////////		priorities.pop();
//////////////////	}
//////////////////}
////////////////#include<iostream>
////////////////#include<algorithm>
////////////////using namespace std;
////////////////class A {
////////////////public:
////////////////	int n;
////////////////	A(int i):n(i){}
////////////////};
////////////////bool operator<(const A&a1, const A&a2) {
////////////////	cout << "<called" << endl;
////////////////	if (a1.n == 3 && a2.n == 7)
////////////////		return true;
////////////////	return false;
////////////////}
////////////////int main() {
////////////////	A aa[] = { 3,5,7,2,1 };
////////////////	cout << min_element(aa, aa + 5)->n << endl;//先默认3最小，然后依次验证5<3是否成立
////////////////	cout << max_element(aa, aa + 5)->n << endl;//先默认3最大，然后依次验证5>3是否成立，想想内部的算法实现
////////////////
////////////////	return 0;
////////////////}
//////////////#include<vector>
//////////////#include<iostream>
//////////////#include<numeric>
//////////////#include<list>
//////////////#include<algorithm>
//////////////#include<iterator>
//////////////using namespace std;
//////////////class CLessThen9 {
//////////////public:
//////////////	bool operator()(int n) { return n < 9; }
//////////////};
//////////////void outputSquare(int value) { cout << value * value << " "; }
//////////////int calculateCube(int value) { return value * value*value; }
//////////////int main() {
//////////////	const int SIZE = 10;
//////////////	int a1[] = { 1,2,3,4,5,6,7,8,9,10 };
//////////////	int a2[] = { 100,2,8,1,50,3,8,9,10,2 };
//////////////	vector<int> v(a1, a1 + SIZE);//直接用一段数组来进行初始化
//////////////	ostream_iterator<int>output(cout, " ");
//////////////	random_shuffle(v.begin(), v.end());
//////////////	cout << endl << "1)";
//////////////	copy(v.begin(), v.end(), output);
//////////////	copy(a2, a2 + SIZE, v.begin());
//////////////	cout << endl << "2)";
//////////////	cout << count(v.begin(), v.end(), 8);
//////////////	cout << endl << "3)";
//////////////	cout << count_if(v.begin(), v.end(), CLessThen9());
//////////////	cout << endl << "7)";
//////////////	for_each(v.begin(), v.end(), outputSquare);//for_each里实现了解引用
//////////////	vector<int>cubes(SIZE);
//////////////	transform(a1, a1 + SIZE, cubes.begin(), calculateCube);
//////////////	cout << endl << "8)";
//////////////	copy(cubes.begin(), cubes.end(), output);
//////////////	return 0;
//////////////}
////////////
////////////#include<iostream>
////////////#include<fstream>
////////////#include<string>
////////////#include<algorithm>
////////////#include<iterator>
////////////using namespace std;
////////////template<class T>
////////////class My_ostream_iterator {
////////////
////////////};
/////////////*
////////////首先要了解清楚copy的源代码
////////////template<class _II,class _OI>
////////////inline _OI copy(_II _F,_II _L, _OI _X){
////////////for(;_F!=_L;++_X,++_F){
////////////*_X=*F;
////////////}
////////////return (_X);}
////////////*/
////////////int main() {
////////////	int a[4] = { 1,2,3,4 };
////////////	My_ostream_iterator<int>oit(cout, "*");
////////////	copy(a, a + 4, oit);
////////////	ofstream oFile("text.txt", ios::out);
////////////	My_ostream_iterator<int> oitf(oFile, "*");
////////////	copy(a, a + 4, oitf);
////////////	oFile.close();
////////////	return 0;
////////////}
//////////#include<algorithm>
//////////#include<vector>
//////////#include<string>
//////////#include<iostream>
//////////#include<iterator>
//////////using namespace std;
//////////bool Greater10(int n) {
//////////	return n > 10;
//////////}
//////////int main() {
//////////	const int SIZE = 10;
//////////	int a1[] = { 2,8,1,50,3,100,8,9,10,2 };
//////////	vector<int> v(a1, a1 + SIZE);
//////////	ostream_iterator<int> output(cout, " ");
//////////	vector<int>::iterator location;
//////////	location = find(v.begin(), v.end(), 10);
//////////	if (location != v.end()) {
//////////		cout << endl << "1)" << location - v.begin();
//////////	}
//////////	location = find_if(v.begin(), v.end(), Greater10);
//////////	if (location != v.end()) {
//////////		cout << endl << "2)" << location - v.begin();
//////////	}
//////////}
////////#include<iostream>
////////#include<cstring>
////////#include<string>
////////#include<algorithm>
////////using namespace std;
//////////class String {
//////////public:
//////////	char *str;
//////////	String() :str(new char[1]) { str[0] = 0; }//应该初始化为空串，而非NULL,NULL没有存储空间
//////////	String(const char *s) {
//////////		str = new char[strlen(s) + 1];
//////////		strcpy(str, s);
//////////	}
//////////	String(const String&s) {//深拷贝
//////////		cout << "copy" << endl;
//////////		str = new char[strlen(s.str) + 1];
//////////		strcpy(str, s.str);
//////////	}
//////////	String&operator=(const String&s) {
//////////		cout << "copy" << endl;
//////////		if (str != s.str) {//如果不等就直接删除，这是很直接的做法
//////////			delete[]str;
//////////			str = new char[strlen(s.str) + 1];
//////////			strcpy(str, s.str);
//////////		}
//////////		return *this;//返回左值引用
//////////	}
//////////	String(String&&s) :str(s.str) {
//////////		cout << "move" << endl;
//////////		s.str = new char[1];
//////////		s.str[0] = 0;//右值引用
//////////	}
//////////	String&operator=(String&&s) {
//////////		cout << "move operator=called" << endl;
//////////		if (str != s.str) {
//////////			delete[]str;
//////////			str = s.str;
//////////			s.str = new char[1];
//////////			s.str[0] = 0;
//////////		}
//////////		return *this;
//////////	}
//////////	~String() { delete[]str; }
//////////	//lambda表达式
//////////
//////////
//////////};
////////class TN {
////////	int n;
////////};
////////class TM {
////////	TN a;
////////	TM&a;
////////	TM*a;
////////
////////};
////////int main()
////////{
////////	int x = 100; int y = 200; int z = 300;
////////	cout << [](double a, double b) {return a + b; }(1.2, 2.5) << endl;
////////	auto ff = [=, &y, &z](int n) {
////////		cout << x << endl;
////////		y++; z++;
////////		return n * n;
////////	};
////////	cout << ff(15) << endl;
////////	cout << y << " " << z << endl;
////////	int a[4] = { 4,2,11,133 };
////////	sort(a, a + 4, [](int x, int y)->bool {return x % 10 < y % 10; });
////////	
////////	
////////}
////////
//////#include<set>
//////#include<iostream>
//////#include<stdio.h>
//////using namespace std;
//////int main() {
//////	int a[5] = { 1,2,3,4,5 };
//////	set<int> st(a, a + 5);
//////	cout << *st.end();
//////}
////
////#include<iostream>
////#include<stdio.h>
////#include<string>
////class CDemo {
////private:
////	int n;
////public:
////	CDemo(int i = 0) :n(i) {};
////	CDemo&operator++() {
////		n++; return *this;
////	}
////	CDemo operator++(int s) {
////		CDemo tmp(*this);
////		n++;
////		return tmp;
////	}
////	operator int() { return n; }
////	friend CDemo&operator--(CDemo&d) {
////		d.n--;
////		return *this;
////	}
////	friend CDemo operator--(CDemo&d, int s) {
////		CDemo tmp(d);
////		d.n--;
////		return tmp;
////	}
////};
////class CBase {
////public:
////	virtual void SomeVirtualFunction(){}
////};
////class CDerived :public CBase {
////public:
////	virtual void SomeVirtualFunciton(){}
////};
////int main() {
////	CDerived ODerived;
////	CBase*p = &ODerived;//原来是这么实现虚函数指向指针，妙啊！
////	p->SomeVirtualFunction();
////	CBase& r = ODerived;
////	r.SomeVirtualFunction();
////}
//////传的是数组元素
/////*
////是void*，不可用*s1来取得其中内容，而应该是p1=(CShape**)s1;CShape**p1;
////*/
////能过就行，放平心态
//#include <algorithm>
//#include <iostream>
//#include <stack>
//#include <queue>
//#include <vector>
//#include <cstring>
//#include <cstdlib>
//#include <string>
//#include <map>
//#include <set>
//
//using namespace std;
//typedef pair<string, int> PAIR;
//class MyMap :public map<string, int>
//{
//public:
//	// 在此处补充你的代码
//	friend istream&operator>>(istream&in, MyMap&n) {
//		PAIR temp;//map的输入都是用PAIRinsert实现的，
//		in >> temp.first >> temp.second;//关联容器的操作都是要插入pair
//		n.insert(temp);
//		return in;
//	}
//	static bool cmp(const PAIR&x, const PAIR&y) {
//		return x.second > y.second || x.second == y.second&&x.first.size() < y.first.size() || x.second == y.second&&x.first.size() == y.first.size() && x.first < y.first;
//		//以此实现多重比较
//	}
//	friend ostream&operator<<(ostream&out, MyMap&n) {
//		//你觉得应该怎么输出，首先要实现排序，那就只能用pair
//		vector<PAIR> v(n.begin(), n.end());
//		sort(v.begin(), v.end(), cmp);
//		for (auto it = v.begin(); it != v.end(); ++it) {
//			out << (*it).first << " " << (*it).second << endl;
//		}return out;
//	}
//};
//int main()
//{
//	int t;
//	cin >> t;
//	while (t--) {
//		int n;
//		cin >> n;
//		MyMap mm;
//		for (int i = 0; i < n; ++i)
//			cin >> mm;
//		cout << mm;
//
//	}
//	return 0;
//}
//#include<iostream>
//#include<string>
//using namespace std;
//template<class T1,class T2>
//class Pair {
//	T1 key;
//	T2 value;
//public:
//	Pair(T1 k, T2 v) :key(k), value(v) {};
//	bool operator <(const Pair<T1, T2>&p)const {
//		return key < p.key;
//	}
//	template<class T3,class T4>
//	friend ostream&operator<<(ostream&o, const Pair<T3, T4>&p) {
//		o << "(" << p.key << "," << p.value << ")";
//		return o;
//	}
//};
