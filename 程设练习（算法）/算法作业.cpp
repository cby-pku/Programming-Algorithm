//////////////////////////////////-----二分和枚举作业----
//////////////////////////////////1.课堂例子：熄灯问题
////////////////////////////////#include<iostream>
////////////////////////////////#include<stdio.h>
////////////////////////////////using namespace std;
////////////////////////////////int puzzle[6][8]; int press[6][8];
////////////////////////////////bool guess() {
////////////////////////////////	int r, c;
////////////////////////////////	for (r = 1; r < 5; ++r) {
////////////////////////////////		for (c = 1; c < 7; ++c) {
////////////////////////////////			press[r + 1][c] = (puzzle[r][c] + press[r][c] + press[r - 1][c] + press[r][c - 1] +
////////////////////////////////				press[r][c + 1]) % 2;
////////////////////////////////		}
////////////////////////////////	}
////////////////////////////////	for (c = 1; c < 7; ++c) {
////////////////////////////////		if ((press[5][c - 1] + press[5][c] + press[5][c + 1] + press[4][c]) % 2 != puzzle[5][c]) {
////////////////////////////////			return false;
////////////////////////////////		}
////////////////////////////////	}
////////////////////////////////	return true;
////////////////////////////////}
////////////////////////////////void enumerate() {
////////////////////////////////	int c;
////////////////////////////////	bool success;
////////////////////////////////	for (c = 1; c < 7; c++) {
////////////////////////////////		press[1][c] = 0;
////////////////////////////////	}
////////////////////////////////	while (guess() == false) {
////////////////////////////////		press[1][1]++;
////////////////////////////////		c = 1;
////////////////////////////////		while (press[1][c] > 1) {
////////////////////////////////			press[1][c] = 0;
////////////////////////////////			c++;
////////////////////////////////			press[1][c]++;
////////////////////////////////		}//相当于是累加进位
////////////////////////////////	}
////////////////////////////////	return;
////////////////////////////////}
////////////////////////////////void print(int n) {
////////////////////////////////	cout << "PUZZLE#" << n << endl;
////////////////////////////////}
////////////////////////////////int main() {
////////////////////////////////	int t;
////////////////////////////////	cin >> t;
////////////////////////////////	for (int r = 0; r < 6; ++r) {
////////////////////////////////		press[r][0] = press[r][7] = 0;
////////////////////////////////	}
////////////////////////////////	for (int c = 1; c < 7; c++) {
////////////////////////////////		press[0][c] = 0;
////////////////////////////////	}
////////////////////////////////	for (int i = 0; i < t; ++t) {
////////////////////////////////		for (int r = 1; r < 6; ++r) {
////////////////////////////////			for (int c = 1; c < 7; ++c) {
////////////////////////////////				cin >> puzzle[r][c];
////////////////////////////////			}
////////////////////////////////		}
////////////////////////////////		//开始循环第一行的状态
////////////////////////////////		enumerate();
////////////////////////////////		print(i + 1);
////////////////////////////////		for (int r = 1; r < 6; ++r) {
////////////////////////////////			for (int c = 1; c < 7; ++c) {
////////////////////////////////				cout << press[r][c] << " ";
////////////////////////////////			}
////////////////////////////////			cout << endl;
////////////////////////////////		}
////////////////////////////////	}
////////////////////////////////}
////////////////////////////////2.课堂例子：讨厌的青蛙
//////////////////////////////#include<iostream>
//////////////////////////////#include<stdio.h>
//////////////////////////////#include<stdlib.h>
//////////////////////////////#include<algorithm>
//////////////////////////////using namespace std;
//////////////////////////////int r, c, n;
//////////////////////////////struct PLANT {
//////////////////////////////	int x, y;
//////////////////////////////};
//////////////////////////////PLANT plants[5001];
//////////////////////////////PLANT plant;
//////////////////////////////int searchPath(PLANT secPlant, int dx, int dy) {
//////////////////////////////	PLANT plant;
//////////////////////////////	int steps;
//////////////////////////////	plant.x = secPlant.x + dx;
//////////////////////////////	plant.y = secPlant.y + dy;
//////////////////////////////	steps = 2;
//////////////////////////////	while (plant.x <= r && plant.x >= 1 && plant.y <= c && plant.y >= 1) {
//////////////////////////////		if (!binary_search(plants, plants + n, plants)) {
//////////////////////////////			steps = 0; break;//非法路径
//////////////////////////////		}
//////////////////////////////		plant.x += dx;
//////////////////////////////		plant.y += dy;
//////////////////////////////
//////////////////////////////		steps++;
//////////////////////////////	}
//////////////////////////////	return (steps);
//////////////////////////////}
//////////////////////////////
//////////////////////////////int main() {
//////////////////////////////	int i, j, dx, dy, px, py, steps, max = 2;
//////////////////////////////	cin >> r >> c;
//////////////////////////////	cin >> n;
//////////////////////////////	for (i = 0; i < n; ++i) {
//////////////////////////////		cin >> plants[i].x >> plants[i].y;
//////////////////////////////	}
//////////////////////////////	sort(plants, plants + n);
//////////////////////////////	for (i = 0; i < n - 2; ++i) {
//////////////////////////////		for (j = i + 1; j < n - 1; ++j) {
//////////////////////////////			dx = plants[j].x - plants[i].x;
//////////////////////////////			dy = plants[j].y - plants[i].y;
//////////////////////////////			px = plants[i].x - dx;
//////////////////////////////			py = plants[i].y - dy;
//////////////////////////////			if (px <= r && px >= 1 && py <= c && py >= 1) {
//////////////////////////////				continue;//前一点在稻田里
//////////////////////////////			}
//////////////////////////////			if (plants[i].x + (max - 1)*dx > r) {
//////////////////////////////				break;//x方向越界了，说明第二点不合适，因为已经排序过，直接break第二点
//////////////////////////////				//换第一点
//////////////////////////////			}
//////////////////////////////			py = plants[i].y + (max - 1)*dy;
//////////////////////////////			if (py > c || py < 1) {
//////////////////////////////				continue;//y方向越界了，换一个点
//////////////////////////////			}
//////////////////////////////			steps = searchPath(plants[i], dx, dy);
//////////////////////////////			if (steps > max)max = steps;
//////////////////////////////		}
//////////////////////////////	}
//////////////////////////////	if (max == 2)max = 0;
//////////////////////////////	cout << max << endl;
//////////////////////////////}
//////////////////////////////bool operator<(const PLANT &p1, const PLANT&p2) {
//////////////////////////////	if (p1.x ==p2.x) {
//////////////////////////////		return p1.y < p2.y;
//////////////////////////////	}
//////////////////////////////	return p1.x < p2.x;
//////////////////////////////}
//////////////////////////////作业：拨钟问题
////////////////////////////#include<iostream>
////////////////////////////#include<stdio.h>
////////////////////////////#include<cstring>
////////////////////////////using namespace std;
////////////////////////////int main() {
////////////////////////////	int i, j;
////////////////////////////	int a[10] = { 0 };
////////////////////////////	int p[10] = { 0 };
////////////////////////////	for (int i = 1; i <= 9; i++) {
////////////////////////////		cin >> a[i];
////////////////////////////	}
////////////////////////////	for (p[1] = 0; p[1] <= 3; p[1]++) {
////////////////////////////		for (p[2] = 0; p[2] <= 3; p[2]++) {
////////////////////////////			for (p[3] = 0; p[3] <= 3; p[3]++) {
////////////////////////////				for (p[4] = 0; p[4] <= 3; p[4]++) {
////////////////////////////					for (p[5] = 0; p[5] <= 3; p[5]++) {
////////////////////////////						for (p[6] = 0; p[6] <= 3; p[6]++) {
////////////////////////////							for (p[7] = 0; p[7] <= 3; p[7]++) {
////////////////////////////								for (p[8] = 0; p[8] <= 3; p[8]++) {
////////////////////////////									for (p[9] = 0; p[9] <= 3; p[9]++) {
////////////////////////////										if ((p[1] + p[2] + p[4] + a[1]) % 4 == 0 &&//本来有a[1]，再加p的1、2、4的操作是4的倍数
////////////////////////////											(p[1] + p[2] + p[3] + p[5] + a[2]) % 4 == 0 &&
////////////////////////////											(p[2] + p[3] + p[6] + a[3]) % 4 == 0 &&
////////////////////////////											(p[1] + p[4] + p[5] + p[7] + a[4]) % 4 == 0 &&
////////////////////////////											(p[1] + p[3] + p[5] + p[7] + p[9] + a[5]) % 4 == 0 &&
////////////////////////////											(p[3] + p[5] + p[6] + p[9] + a[6]) % 4 == 0 &&
////////////////////////////											(p[4] + p[7] + p[8] + a[7]) % 4 == 0 &&
////////////////////////////											(p[5] + p[7] + p[8] + p[9] + a[8]) % 4 == 0 &&
////////////////////////////											(p[6] + p[8] + p[9] + a[9]) % 4 == 0) {
////////////////////////////											for (i = 1; i <= 9; i++)
////////////////////////////												if (p[i] != 0)
////////////////////////////													for (j = 1; j <= p[i]; j++)
////////////////////////////														cout << i << " ";
////////////////////////////											return 0;
////////////////////////////										}
////////////////////////////									}
////////////////////////////								}
////////////////////////////							}
////////////////////////////						}
////////////////////////////					}
////////////////////////////				}
////////////////////////////			}
////////////////////////////		}
////////////////////////////	}
////////////////////////////}
////////////////////////////特殊密码锁
//////////////////////////#include<iostream>
//////////////////////////#include<algorithm>
//////////////////////////#include<string>
//////////////////////////using namespace std;
//////////////////////////int str2it(string s) {
//////////////////////////	int ans = 0; int len = s.length();
//////////////////////////	for (int i = 0; i < len; ++i) {
//////////////////////////		if (s[i] == '1') {
//////////////////////////			ans += (1 << (len - i - 1));
//////////////////////////		}
//////////////////////////	}
//////////////////////////	return ans;
//////////////////////////}
//////////////////////////void flip(int &n, int pos) {//默认右侧是第一位，非传统二进制写法
//////////////////////////	if (pos == 1) {
//////////////////////////		n ^= 1; n ^= 2;
//////////////////////////		return;
//////////////////////////	}
//////////////////////////	for (int i = pos - 1; i <= pos + 1; i++) {
//////////////////////////		n ^= (1 << i - 1);
//////////////////////////	}
//////////////////////////}
//////////////////////////int solution(int a, int len) {
//////////////////////////	int ans = 0;
//////////////////////////	for (int i = 1; i <= len; ++i) {
//////////////////////////		if ((a >> i - 1) & 1) {//右侧第一位
//////////////////////////			if (i == len) {
//////////////////////////				return 0x7f7f7f7f;
//////////////////////////			}
//////////////////////////			ans++;
//////////////////////////			flip(a,i + 1);//翻下一位，才能让这一位位0
//////////////////////////		}
//////////////////////////	}
//////////////////////////	return ans;
//////////////////////////}
//////////////////////////int main() {
//////////////////////////	string s1, s2;
//////////////////////////	cin >> s1 >> s2;
//////////////////////////	int a, len, ans = 0x7f7f7f7f;
//////////////////////////	len = s1.length();
//////////////////////////	a = str2it(s1) ^ str2it(s2);
//////////////////////////	//先翻第一位
//////////////////////////	
//////////////////////////	flip(a, 1);
//////////////////////////	ans = min(ans, solution(a, len) + 1);
//////////////////////////	
//////////////////////////	if (ans >= 0x7f7f7f7f) {
//////////////////////////		cout << "impossible";
//////////////////////////	}
//////////////////////////	else {
//////////////////////////		cout << ans;
//////////////////////////	}
//////////////////////////}
//////////////////////////3：派
////////////////////////#include<iostream>
////////////////////////#include<cmath>
////////////////////////#include<algorithm>
////////////////////////#include<iomanip>
////////////////////////using namespace std;
////////////////////////int n, f;//f是朋友数量，n为派的数量
////////////////////////double l = 0x7f7f7f7f, r = 0;
////////////////////////double s[10010] = { 0 };
////////////////////////double ans;
////////////////////////bool accept() {
////////////////////////	int cnt = 0;
////////////////////////	for (int i = 1; i <= n; i++) {
////////////////////////		cnt += int(s[i] / ans);
////////////////////////	}
////////////////////////	if (cnt >= f+1)return true;
////////////////////////	return false;
////////////////////////}
////////////////////////int main() {
////////////////////////	cin >> n >> f;
////////////////////////	const double pi = acos(-1.0);
////////////////////////	const double eps = 1e-5;
////////////////////////	for (int i = 1; i <= n; i++) {
////////////////////////		cin >> s[i];
////////////////////////		s[i] = pi * s[i] * s[i];
////////////////////////		l = min(l, s[i]);
////////////////////////		r = max(r, s[i]);
////////////////////////	}
////////////////////////	l /= f + 1;
////////////////////////	while ((r - l) > eps) {
////////////////////////		ans = (r + l) / 2;
////////////////////////		if (accept()) {
////////////////////////			l = ans;
////////////////////////		}
////////////////////////		else {
////////////////////////			r = ans;
////////////////////////		}
////////////////////////	}
////////////////////////	cout << fixed << setprecision(3) << ans << endl;
////////////////////////}
////////////////////////4：河中跳房子
//////////////////////#include<iostream>
//////////////////////#include<stdio.h>
//////////////////////#include<vector>
//////////////////////#include<algorithm>
//////////////////////using namespace std;
//////////////////////int L, n, m;
//////////////////////vector<int>stone;
//////////////////////bool accept(int dis) {
//////////////////////	int cnt = 0, j = 0;
//////////////////////	for (int i = 1; i <= n + 1; i++) {
//////////////////////		if (stone[i] - stone[j] < dis) {
//////////////////////			cnt++;//说明可以拿走j处石头
//////////////////////		}
//////////////////////		else {
//////////////////////			j = i;
//////////////////////		}
//////////////////////	}
//////////////////////	return cnt <= m;//移走之多m块石头，看好题目要求
//////////////////////}
//////////////////////int main() {
//////////////////////	cin >> L >> n >> m;
//////////////////////	stone.resize(n + 2);
//////////////////////	stone[0] = 0; stone[n + 1] = L;
//////////////////////	for (int i = 1; i <= n; i++) {
//////////////////////		cin >> stone[i];
//////////////////////	}
//////////////////////	int l = 0; int r = L + 1;//
//////////////////////	int ans = 0;
//////////////////////	while (l + 1 != r) {
//////////////////////		ans = (l + r) / 2;//枚举最短距离
//////////////////////		if (accept(ans)) {
//////////////////////			l = ans;
//////////////////////		}
//////////////////////		else {
//////////////////////			r = ans;
//////////////////////		}
//////////////////////	}
//////////////////////	cout <<l << endl;
//////////////////////}
////////////////////
//////////////////////----递归作业---
//////////////////////1.课堂例子：小游戏
////////////////////#include<stdio.h>
////////////////////#include<memory.h>
////////////////////#define MAXIN 75
////////////////////#include<iostream>
////////////////////char board[MAXIN + 2][MAXIN + 2];//定义矩形板
////////////////////int minstep, w, h, to[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };//定义方向
////////////////////bool mark[MAXIN + 2][MAXIN + 2];//定义标记数组
////////////////////void Search(int now_x, int now_y, int end_x, int end_y, int step, int f) {
////////////////////	if (step > minstep)return;//当前路径数大于minstep返回->优化策略
////////////////////	if (now_x == end_x && now_y == end_y) {//到达终点
////////////////////		if (minstep > step) {
////////////////////			minstep = step;
////////////////////			return;
////////////////////		}
////////////////////
////////////////////	}
////////////////////	//如果以上条件均不满足
////////////////////	for (int i = 0; i < 4; i++) {
////////////////////		int x = now_x + to[i][0];
////////////////////		int y = now_y + to[i][1];
////////////////////		if ((x > -1) && (x < w + 2) && (y > -1) && (y < h + 2)
////////////////////			&& (((board[y][x] == ' ') && (mark[y][x] == false)) || ((x == end_x)
////////////////////				&& (y == end_y) && (board[y][x] == 'X')))) {
////////////////////			//如果是新位置，那就标记该位置
////////////////////			//已经过上一步方向和当前方向相同，则递归搜索时step不变，否则step+1
////////////////////			mark[y][x] = true;
////////////////////			if (f == i) {
////////////////////				Search(x, y, end_x, end_y, step, i);
////////////////////			}
////////////////////			else { Search(x, y, end_x, end_y, step + 1, i); }
////////////////////			mark[y][x] = false;//回溯
////////////////////		}
////////////////////	}
////////////////////
////////////////////}
////////////////////using namespace std;
////////////////////int main() {
////////////////////	int Boardnum = 0;
////////////////////	while (cin >> w >> h) {
////////////////////		if (w == 0 && h == 0)break;
////////////////////		Boardnum++;
////////////////////		cout << "Board #" <<Boardnum<< endl;
////////////////////		int i, j;
////////////////////		for (i = 0; i < MAXIN + 2; i++)board[0][i] = board[i][0] = ' ';
////////////////////		for (i = 1; i <= h; i++) {
////////////////////			getchar();
////////////////////			for (j = 1; j <= w; j++) {
////////////////////				board[i][j] = getchar();
////////////////////			}
////////////////////		}
////////////////////		//在矩形板最外面层加一圈格子
////////////////////		for (i = 0; i <= w; i++) {
////////////////////			board[h + 1][i + 1] = ' ';
////////////////////		}
////////////////////		for (i = 0; i <= h; i++)
////////////////////			board[i + 1][w + 1] = ' ';
////////////////////		int begin_x, begin_y, end_x, end_y, count = 0;
////////////////////		while ((cin >> begin_x >> begin_y >> end_x >> end_y) && begin_x > 0) {
////////////////////			count++;
////////////////////			minstep = 100000;
////////////////////			memset(mark, false, sizeof(mark));
////////////////////			//递归搜索
////////////////////			Search(begin_x, begin_y, end_x, end_y, 0, -1);
////////////////////			//输出结果
////////////////////			if (minstep < 100000)
////////////////////				printf_s("Pair %d: %d segments.\n", count, minstep);
////////////////////			else
////////////////////				printf_s("Pair %d:impossible.\n", count);
////////////////////		}
////////////////////		printf_s("\n");
////////////////////	}return 0;
////////////////////}
////////////////////课堂例子2：棋盘分割
//////////////////#include<iostream>
//////////////////#include<stdio.h>
//////////////////#include<algorithm>
//////////////////#include<iomanip>
//////////////////using namespace std;
//////////////////int s[9][9];//每个格子的分数
//////////////////int sum[9][9];//从(1,1)到(i,j)矩形的分数之和
//////////////////int res[15][9][9][9][9];//fun的分数表
//////////////////int calSum(int x1, int x2, int y1, int y2) {
//////////////////	return sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] + sum[x1 - 1][y1 - 1];//这个是真的牛哇
//////////////////}//小trick
//////////////////int fun(int n, int x1, int y1, int x2, int y2) {
//////////////////	int t, a, b, c, e, MIN = 10000000;
//////////////////	if (res[n][x1][y1][x2][y2] != -1)
//////////////////		return res[n][x1][y1][x2][y2];
//////////////////	if (n == 1) {
//////////////////		t = calSum(x1, y1, x2, y2);
//////////////////		res[n][x1][y1][x2][y2] = t * t;
//////////////////		return t * t;//这算得对吗？？
//////////////////	}
//////////////////	//多次划分时
//////////////////	for (a = x1; a < x2; a++) {
//////////////////		c = calSum(a + 1, y1, x2, y2);
//////////////////		e = calSum(x1, y1, a, y2);
//////////////////		t = min(fun(n - 1, x1, y1, a, y2) + c * c , fun(n - 1, a + 1, y1, x2, y2) + e * e);
//////////////////		if (MIN > t)MIN = t;
//////////////////	}
//////////////////	for (b = y1; b < y2; b++) {
//////////////////		c = calSum(x1, b + 1, x2, y2);
//////////////////		e = calSum(x1, y1, x2, b);
//////////////////		t = min(fun(n - 1, x1, y1, x2, b) + c * c, fun(n - 1, x1, b + 1, x2, y2) + e * e);
//////////////////		if (MIN > t)MIN = t;
//////////////////	}
//////////////////	res[n][x1][y1][x2][y2] = MIN;
//////////////////	return MIN;
//////////////////}
//////////////////int main() {
//////////////////	memset(sum, 0, sizeof(sum));
//////////////////	memset(res, -1, sizeof(res));//初始化记录表
//////////////////	int n;
//////////////////	cin >> n;
//////////////////	for (int i = 1; i < 9; i++) {
//////////////////		for (int j = 1, rowsum = 0; j < 9; j++) {
//////////////////			cin >> s[i][j];
//////////////////			rowsum += s[i][j];
//////////////////			sum[i][j] += sum[i - 1][j] + rowsum;
//////////////////		}
//////////////////	}
//////////////////	double result = n * fun(n, 1, 1, 8, 8) - sum[8][8] * sum[8][8];
//////////////////	cout << setioflags(ios::fixed) << setprecision(3) << sqrt(result / n * n) << endl;
//////////////////}
//////////////////1.boolean expressions
////////////////#include<iostream>
////////////////#include<stdio.h>
////////////////#include<algorithm>
////////////////using namespace std;
////////////////bool factor_value();
////////////////bool expression_value();
////////////////int main() {
////////////////	int cnt = 1;
////////////////	while (cin.peek() != EOF) {
////////////////		cout << "Expression " << cnt << ": ";
////////////////		cnt++;
////////////////		if (expression_value()) {//expression_value中需要读取这个元素，所以不能提前拿
////////////////			cout << "V" << endl;
////////////////		}
////////////////		else {
////////////////			cout << "F" << endl;
////////////////		}
////////////////		cin.get();
////////////////	}
////////////////}
////////////////bool factor_value() {
////////////////	char next = cin.peek();
////////////////	while (next == ' ') {
////////////////		cin.get();
////////////////		next = cin.peek();
////////////////
////////////////	}
////////////////	if (next == '!') {
////////////////		cin.get();
////////////////		return !factor_value();//递归调研
////////////////	}
////////////////	else if (next == 'V') {
////////////////		cin.get();
////////////////		return true;
////////////////	}
////////////////	else if (next == 'F') {
////////////////		cin.get();
////////////////		return false;
////////////////	}
////////////////	else if (next == '(') {
////////////////		cin.get();
////////////////		bool result = expression_value();
////////////////		cin.get();
////////////////		return result;
////////////////	}
////////////////}
////////////////bool expression_value() {
////////////////	bool result = factor_value();
////////////////	while (true) {
////////////////		char next = cin.peek();
////////////////		if (next == '&') {
////////////////			cin.get();
////////////////			bool next_value = factor_value();
////////////////			result &= next_value;
////////////////		}
////////////////		else if (next == '|') {
////////////////			cin.get();
////////////////			bool next_value = factor_value();
////////////////			result |= next_value;
////////////////		}
////////////////		else if (next == ' ') {
////////////////			cin.get();
////////////////		}
////////////////		else { break; }
////////////////	}
////////////////	return result;
////////////////}
////////////////数据结构：图
//////////////#include<iostream>
//////////////#include<string>
//////////////#include<stdio.h>
//////////////#include<algorithm>
//////////////#include<vector>
//////////////using namespace std;
//////////////int cnt = 1;
//////////////bool Data_structure(int level, string Dialog) {
//////////////	vector<string>file;
//////////////	string tmp;
//////////////	char next;
//////////////	if (level == 0) {
//////////////		cout << "DATA SET " << cnt << ":" << endl;
//////////////		cnt++;
//////////////	}
//////////////	for (int i = 0; i < level; i++) {
//////////////		cout << "|     ";
//////////////	}
//////////////	cout << Dialog << endl;
//////////////	while (true) {
//////////////		next = cin.peek();
//////////////		if (next == '*' | next == ']') {
//////////////			cin.get(); cin.get();//及时吃掉
//////////////			break;
//////////////		}
//////////////		else if (next == 'f') {
//////////////			cin >> tmp;
//////////////			cin.get();//吃掉换行符
//////////////			file.push_back(tmp);
//////////////		}
//////////////		else if (next == 'd') {
//////////////			cin >> tmp;
//////////////			cin.get();
//////////////			Data_structure(level + 1, tmp);
//////////////		}
//////////////	}
//////////////	//实现同一级file的全部读取，开始输出
//////////////	sort(file.begin(), file.end());
//////////////	for (int i = 0; i < file.size(); i++) {
//////////////		for (int j = 0; j < level; j++) {
//////////////			cout << "|     ";
//////////////		}
//////////////		cout << file[i] << endl;
//////////////	}
//////////////	if (cin.peek() == '#')
//////////////		return false;
//////////////	return true;
//////////////
//////////////}
//////////////int main() {
//////////////	bool note = true;
//////////////	while (note) {
//////////////		note = Data_structure(0, "ROOT");
//////////////		cout << endl;
//////////////	}
//////////////}
////////////
//////////////3：the sierpinski fractal
////////////#include<iostream>
////////////#include<stdio.h>
////////////#include<algorithm>
////////////using namespace std;
////////////int n;
////////////char a[5000][5000];
////////////void plot(int x, int y, int t) {
////////////	if (t == 1) {
////////////		a[x][y] = '/'; a[x - 1][y + 1] = '/'; a[x - 1][y + 2] = '\\';
////////////		a[x][y + 3] = '\\'; a[x][y + 1] = '_'; a[x][y + 2] = '_';
////////////		return;
////////////	}
////////////	int bottom = 1 << (t + 1); int h = 1 << t;
////////////	plot(x - h / 2, y + bottom / 4, t - 1);
////////////	plot(x, y, t - 1);
////////////	plot(x, y + bottom / 2, t - 1);
////////////}
////////////void Print() {
////////////	for (int i = 1; i <= (1 << n); i++) {//行数是高
////////////		for (int j = 0; j <= (1 << (n + 1)); j++) {
////////////			cout << a[i][j];
////////////		}
////////////		cout << endl;
////////////	}
////////////}
////////////void Init() {
////////////	int tmp = 1 << 10 + 1;
////////////	for (int i = 0; i < tmp; i++) {
////////////		for (int j = 0; j < tmp * 2; j++) {
////////////			a[i][j] = ' ';
////////////		}
////////////	}
////////////}
////////////int main() {
////////////	while (cin >> n && n != 0) {
////////////		Init();
////////////		plot(1<<n,0,n);
////////////		Print();
////////////		cout << endl;
////////////	}
////////////}
//////////
////////////-------3----动态规划
//////////最大数字三角形：递归解法
//////////#include<iostream>
//////////#include<stdio.h>
//////////#include<algorithm>
//////////#define MAX 101
//////////using namespace std;
//////////int D[MAX][MAX];
//////////int maxSum[MAX][MAX];
//////////int n;
//////////int MaxSum(int i, int j) {
//////////	if (maxSum[i][j] != -1)
//////////		return maxSum[i][j];
//////////	if (i == n)
//////////		return D[i][j];
//////////	int x = MaxSum(i + 1, j);
//////////	int y = MaxSum(i + 1, j + 1);
//////////	return max(x, y) + D[i][j];
//////////}
//////////int main() {
//////////	int i, j;
//////////	cin >> n;
//////////	for (i = 1; i <= n; i++) {
//////////		for (j = 1; j <= i; j++) {
//////////			cin >> D[i][j];
//////////			maxSum[i][j] = -1;
//////////		}
//////////	}
//////////	cout << MaxSum(1, 1) << endl;
//////////}
//////////
////////////最大数字三角形：动规解法
//////////#include<iostream>
//////////#include<stdio.h>
//////////#include<algorithm>
//////////#define MAX 101
//////////using namespace std;
//////////int D[MAX][MAX];
//////////int maxSum[MAX][MAX];
//////////int n;
//////////int main() {
//////////	int i, j;
//////////	cin >> n;
//////////	for (i = 1; i <= n; i++) {
//////////		for (j = 1; j <= i; j++) {
//////////			cin >> D[i][j];
//////////		}
//////////	}
//////////	for (int i = 1; i <= n; i++) {
//////////		maxSum[n][i] = D[n][i];
//////////	}
//////////	for (int i = n - 1; i >= 1; i--) {
//////////		for (int j = 1; j <= i; j++) {
//////////			maxSum[i][j] = max(maxSum[i + 1][j], maxSum[i + 1][j + 1]) + D[i][j];
//////////		}
//////////	}
//////////	cout << maxSum[1][1] << endl;
//////////}
////////
//////////波兰表达式
//////////#include<iostream>
//////////#include<stdio.h>
//////////#include<cmath>
//////////using namespace std;
//////////double exp() {
//////////	char a[10];
//////////	scanf("%s", &a);//%s是字符串啊
//////////	switch (a[0])
//////////	{
//////////	case '*':return exp()*exp();
//////////	case '+':return exp() + exp();
//////////	case '-':return exp() - exp();
//////////	case '/':return exp() / exp();
//////////	default:return atof(a);
//////////	}
//////////}
//////////int main() {
//////////	double ans;
//////////	ans = exp();
//////////	printf("%f", ans);
//////////	return 0;
//////////}
////////
//////////正常运算表达式
////////#include<iostream>
////////#include<stdio.h>
////////#include<cstring>
////////#include<cstdlib>
////////#include<cstdio>
////////using namespace std;
////////double itemvalue();
////////double factorvalue();
////////
////////double expvalue() {//表达式的话，肯定先读入一个项
////////	double v = itemvalue();
////////	while (true) {
////////		char c = cin.peek();
////////		if (c == '-') {
////////			cin.get();
////////			v -= itemvalue();
////////		}
////////		else if (c == '+'){
////////			cin.get();
////////			v += itemvalue();
////////		}
////////		else break;
////////	}
////////	return v;
////////}
////////double itemvalue() {
////////	double v = factorvalue();
////////	while (true) {
////////		char c = cin.peek();
////////		if (c == '*') {
////////			cin.get();
////////			v *= factorvalue();
////////		}
////////		else if (c == '/') {
////////			cin.get();
////////			v /= factorvalue();
////////		}
////////		else break;
////////	}return v;
////////}
////////double factorvalue() {
////////	double v;
////////	char c = cin.peek();
////////	if (c == '(') {
////////		cin.get();
////////		v = expvalue();
////////		cin.get();
////////	}
////////	else {
////////		cin >> v;
////////	}
////////	return v;//最大的，不必重复whiletrue
////////}
//////
////////方盒游戏
//////#include<cstring>
//////#include<iostream>
//////using namespace std;
//////struct box_segment {
//////	int color;
//////	int len;
//////};
//////box_segment segment[200];
//////int click_box(int start, int end, int extra_len) {
//////	int i;
//////	int result, temp;
//////	result = segment[end].len + extra_len;
//////	result = result * result;
//////	if (start == end)return result;
//////	result += click_box(start, end - 1, 0);
//////	for (i = end - 1; i >= start; i--) {
//////		if (segment[i].color != segment[end].color)continue;
//////		temp = click_box(start, i, segment[end].len + extra_len) + click_box(i + 1, end - 1, 0);
//////		if (temp <= result)continue;
//////		result = temp; break;
//////	}
//////	return result;
//////}
//////int main() {
//////	int t, n, i, j, end, color;
//////	cin >> t;
//////	for (i = 0; i < t; i++) {
//////		cin >> n; end = 0; cin >> segment[end].color;
//////		segment[end].len = 1;
//////		for (j = 1; j < n; j++) {
//////			cin >> color;
//////			if (color == segment[end].color)segment[end].len++;
//////			else {
//////				end++;
//////				segment[end].color = color;
//////				segment[end].len = 1;
//////			}
//////		}
//////		cout << "Case " << i + 1 << ":" << click_box(0, end, 0) << endl;
//////
//////	}
//////}
////
////
//////------动规--------
//////#include<iostream>
//////#include<stdio.h>
//////#include<algorithm>
//////#include<cstring>
//////using namespace std;
//////const int MAXN = 1010;
//////int a[MAXN]; int maxLen[MAXN];
//////int main() {
//////	int N; cin >> N;
//////	for (int i = 1; i < N; ++i) {
//////		cin >> a[i];
//////		maxLen[i] = 1;
//////	}
//////	for (int i = 2; i <= N; ++i) {
//////		for (int j = 1; j < i; ++j) {
//////			if (a[i] > a[j])
//////				maxLen[i] = max(maxLen[i], maxLen[j] + 1);
//////		}
//////	}
//////	cout << *max_element(maxLen + 1, maxLen + N + 1);
//////}
////
//////滑雪
////#include<iostream>
////#include<stdio.h>
////#include<algorithm>
////using namespace std;
////int dx[4] = { 0,0,1,-1 };
////int dy[4] = { 1,-1,0,0 };
////int height[102][102] = { {1} };
////int r, c;
////int dp[102][102] = { {1} };
////bool visit[102][102] = { {false }};
////int ans = -1;
////bool valid(int x, int y) {
////	return (x >= 1) && (x <= r) && (y >= 1) && (y <= c);
////}
////void search(int x, int y) {
////	visit[x][y] = true;
////	dp[x][y] = max(dp[x][y], 1);//先初始化一下
////	for (int dir = 0; dir < 4; dir++) {
////		int xx = x + dx[dir]; int yy = y + dy[dir];
////		if (valid(xx, yy) && height[xx][yy] < height[x][y]) {
////			if (!visit[xx][yy])
////				search(xx, yy);
////			dp[x][y] = max(dp[x][y], dp[xx][yy] + 1);
////		}
////	}
////	ans = max(ans, dp[x][y]);
////}
////int main() {
////	cin >> r >> c;
////	for (int i = 1; i <= r; i++) {
////		for (int j = 1; j <= c; j++) {
////			cin >> height[i][j];
////		}
////	}
////	for (int i = 1; i <= r; i++) {
////		for (int j = 1; j <= c; j++) {
////			search(i, j);
////		}
////	}
////	cout << ans << endl;
////}
//
//////怪盗基德的滑翔翼，最大上升子序列和最大下降子序列
////#include<stdio.h>
////#include<iostream>
////#include<algorithm>
////#include<vector>
////using namespace std;
////int main() {
////	int N;
////	cin >> N; int n;
////
////	while (N--) {
////		cin >> n;
////		int ans = -1;
////		//利用vector可以重开数组的特性
////		vector<int>h, dp1, dp2;
////		h.resize(n, 1);
////		dp1.resize(n, 1);
////		dp2.resize(n, 1);
////		for (int i = 0; i < n; i++) {
////			cin >> h[i];
////		}
////		for (int i = 1; i < n; i++) {
////			for (int j = 0; j < i; j++) {
////				if (h[j] > h[i])
////					dp1[i] = max(dp1[i], dp1[j] + 1);
////				else if (h[j] < h[i])
////					dp2[i] = max(dp2[i], dp2[j] + 1);
////			}
////			ans = max(ans, dp1[i]);
////			ans = max(ans, dp2[i]);
////		}
////		cout << ans << endl;
////	}
////}
//
//////最佳加法表达式
////#include<iostream>
////#include<stdio.h>
////#include<string>
////#include<cstring>
////#include<algorithm>
////using namespace std;
////const int N = 110;
////string add(string a, string b) {//直接用string，防止大整数无法比较
////	int la = a.length(); int lb = b.length();
////	string ans; int lm = max(la, lb);
////	int a1[N] = { 0 }; int b1[N] = { 0 };//不初始化真要命@
////	reverse(a.begin(), a.end());
////	reverse(b.begin(), b.end());
////	for (int i = 0; i < la; i++) {
////		a1[i] = a[i] - '0';
////	}
////	for (int i = 0; i < lb; i++) {
////		b1[i] = b[i] - '0';
////	}
////	for (int i = 0; i < lm; i++) {
////		a1[i] = a1[i] + b1[i];
////		a1[i + 1] += (a1[i] / 10);
////		a1[i] %= 10;
////	}
////	if (a1[lm])lm++;
////	for (int i = lm-1; i >=0; i--) {
////		ans += a1[i] + '0';
////	}
////	return ans;
////}
////int main() {
////	int m; string a;
////	string Maxs;
////	for (int i = 0; i < 50; i++) {
////		Maxs += '9';
////	}
////	while (cin >> m >> a) {
////		string dp[52][52];//加号个数，前多少位
////		int l = a.length();
////		for (int i = 1; i <= l; i++) {
////			dp[0][i] = a.substr(0, i);
////		}
////		for (int i = 1; i <= m; i++) {//最外层循环加号个数
////			for (int j = i+1; j <= l; j++) {//j个数字参与
////				dp[i][j] = Maxs;
////				for (int k = i; k < j; k++) {//最后的字符串位置
////					string tmp = add(dp[i - 1][k], a.substr(k, j - k));
////					if ((tmp.length() < dp[i][j].length()) || (tmp.length() == dp[i][j].length() && tmp < dp[i][j])) {
////						dp[i][j] = tmp;
////					}
////				}
////			}
////		}
////		cout << dp[m][l] << endl;
////	}
////}
////
//////BFS：八数码问题
////#include<iostream>
////#include<cstring>
////using namespace std;
////
////
////Node myQueue[MAXS];
////int qHead;
////int qTail;//队首和队尾指针
////
////char sz4Moves[] = "udrl";
////unsigned int factorial[21];
////
//////GetPermutationNum
//////这段还是誊抄一下课上的代码，仔细学习一下
////void IntStatusToStrStatus(int a,char*s);
////int newStatus(int nStatus, char cMove) {
////	char szTmp[20];
////	int nZeroPos;
////	IntStatusToStrStatus(nStatus, szTmp);
////
////}
//
//
////美妙的栅栏：动态规划之不断细化状态
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//using namespace std;
//const int UP = 0; const int DOWN = 1;
//const int MAXN = 25;
//long long C[MAXN][MAXN][2];
////c[i][k][down]是s(i)中以第k短的木棒打头的down方案数
////c[i][k][up]是s(i)中以第k短的木棒打头的up方案数
////第k短是i根中第k短
//void Init(int n) {
//	memset(C, 0, sizeof(C));
//	C[1][1][UP] = C[1][1][DOWN] = 1;
//	for (int i = 2; i <= n; ++i) {
//		for (int k = 1; k <= i; +k) {//枚举第一根木棒的长度，第k短
//			for (int M = k; M < i; ++M) {//枚举第二根木棒的长度，比第一根长
//				C[i][k][UP] += C[i - 1][M][DOWN];
//			}
//			for (int N = 1; N <= k - 1; ++N) {//枚举第二根的长度，比第一根短
//				C[i][k][DOWN] += C[i - 1][N][UP];
//			}
//		}
//	}//总方案数是sum{C[n][k][DOWN]+C[n][k][UP]}k=1^n
//	//复杂度n2
//}
//void Print(int n, long long cc) {//n根木棒，求第cc个排列
//	long long skipped = 0;//求已经跳过的方案数
//	int seq[MAXN];//最终要输出的答案
//	int used[MAXN];//木棒是否用过
//	memset(used, 0, sizeof(used));
//	for (int i = 1; i <= n; ++i) {//依次确定每一个位置i的木棒
//		int k = 0;
//		int No = 0;//长度为k的木棒是剩下的木棒里第no短的，no从1开始计算
//		for (k = 1; k <= n; ++k) {
//			//枚举位置i的木棒长度k
//			skipped = 0;
//			if (!used[k]) {
//				++No;//k是剩下木棒里第No短的
//				if (i == 1)
//					skipped = C[n][No][UP] + C[n][No][DOWN];
//				else {
//					if (k > seq[i - 1] && (i <= 2 || seq[i - 2] > seq[-1]))
//						skipped = C[n - i + 1][No][DOWN];//合法放置
//					else if (k < seq[i - 1] && (i <= 2 || seq[i - 2] < seq[-1]))
//						skipped = C[n - i + 1][No][UP];
//				}
//				if (skipped >= cc)break;
//				else cc -= skipped;
//			}
//		}
//		used[k] = true;
//		seq[i] = k;
//	}
//	for (int i = 1; i <= n; ++i) {
//		if (i < n)printf("%d ", seq[i]);
//		else printf("%d ", seq[i]);
//
//	}
//	cout << endl;
//}
//int main() {
//	int T; int n;
//	long long c;
//	Init(20);
//	scanf("%d", &T);
//	while (T--) {
//		cin >> n >> c;
//		Print(n, c);
//	}
//	return 0;
//}


//
////动规作业2
////整数分划
//#include<iostream>
//#include<algorithm>
//#include<cstring>
//const int N = 505;
//using namespace std;
//long long dp[N][N];
//long long Cut(int n) {//小心越界
//	memset(dp,0, sizeof(dp));
//	for (int i = 1; i < N; i++) {
//		dp[0][i] = 1;
//	}
//	for (int i = 1; i < N; i++) {
//		for (int j = i / 2 + 1; j <= i; j++)
//			dp[i][j] = 1;
//	}
//	for (int i = 2; i < N; i++) {
//		for (int j = i / 2; j > 0; j--) {
//			dp[i][j] = dp[i - 2 * j][j] + dp[i][j + 1];
//		}
//	}
//	return dp[n][1];
//}
//int main() {
//	int n;
//	while (cin >> n && n != 0) {
//		cout << n << " " << Cut(n)<<endl;
//	}
//}
//
////硬币问题
//#include<iostream>
//using namespace std;
//int main() {
//	int n, sum;
//	int a[200]; int dp[10001];
//	cin >> n >> sum;
//	for (int i = 0; i < n; i++) {
//		cin >> a[i];
//	}
//	dp[0] = 1;
//	for (int i = 0; i < n; i++) {
//		for (int j = sum; j >= a[i]; j--) {
//			dp[j] += dp[j - a[i]];
//		}
//	}
//	int ans[201] = { 0 };
//	for (int i = 0; i < n; i++) {
//		for (int j = a[i]; j <= sum; j++) {
//			dp[j] -= dp[j - a[i]];
//		}
//		if (dp[sum] == 0)
//			ans[++ans[0]] = a[i];
//		for (int j = sum; j >= a[i]; j--) {
//			dp[j] += dp[j - a[i]];
//		}
//	}
//	cout << ans[0] << endl;
//	for (int i = 1; i <= ans[0]; i++)
//		cout << ans[i] << " ";
//	cout << endl;
//}

//#include <iostream>
//using namespace std;
//int dp[10001];
//int calc(int x, int v) {
//	if (x < 0)return 0;
//	else return dp[x] - calc(x - v, v);
//
//}
//int main() {
//	int n, sum, a[200];
//	cin >> n >> sum;
//	for (int i = 0; i < n; i++)
//		cin >> a[i];
//	dp[0] = 1;
//	for (int i = 0; i < n; i++)
//		for (int j = sum; j >= a[i]; j--)
//			dp[j] += dp[j - a[i]];//先算出来所有硬币的组合数目（使用了滚动数组）
//	int ans[201] = { 0 };
//	for (int i = 0; i < n; i++) {
//		if (!(dp[sum] - calc(sum - a[i], a[i]))) {
//			ans[++ans[0]] = a[i];
//		}
//	}
//	cout << ans[0] << endl;
//	for (int i = 1; i <= ans[0]; i++)
//		cout << ans[i] << ' ';
//	cout << endl;
//}
//
//#include<iostream>
//#include<algorithm>
//using namespace std;
//const int N = 3500;
//int n, m;
//int w[N];
//int v[N];
//int dp[4 * N];
//int main() {
//	cin >> n >> m;
//	for (int i = 1; i <= n; i++) {
//		cin >> w[i] >> v[i];
//	}
//	//dp[i][j]取前i种物品，不超过体积j，的最大价值
//	for (int j = 0; j <= m; j++) {
//		if (w[1] <= j)dp[j] = v[1];
//		else dp[j] = 0;
//	}//初始化，循环体积j
//	for (int i = 2; i <= n; i++) {
//		for (int j = m; j >=0; j--) {
//			if (j >= w[i])//还是非常简单的第一道动规题yeah！亲手实现
//				dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
//		}
//	}
//	cout << dp[m] << endl;
//}


////状态压缩典型例题，remember it！！
//#include<iostream>
//#include<stdio.h>
//#include<vector>
//#include<algorithm>
//#include<string>
//using namespace std;
//int main() {
//	int N;
//	cin >> N;
//	while (N--) {
//		int n; cin >> n;
//		int ddl[16], time[16];
//		string name[16];
//		for (int i = 0; i < n; i++) {
//			cin >> name[i] >> ddl[i] >> time[i];
//		}
//		//状态压缩
//		vector<int>sum(1 << n, 0);
//		for (int i = 0; i < (1 << n); i++) {
//			for (int j = 0; j < n; j++) {
//				if (i&(1 << j)) {//如果这种情况选了第j门课
//					sum[i] = sum[i ^ (1 << j)] + time[j];//sum记录的是时间总和
//				}
//			}
//		}
//		vector<int>dp(1 << n, 0x3f3f3f3f);//前i个课的最小扣分
//		dp[0] = 0;
//		vector<string>ans(1 << n);
//		for (int i = 1; i < (1 << n); i++) {
//			for (int j = 0; j < n; j++) {
//				if (i&(1 << j)) {//比较如果不上这课需要扣多少分
//					int koufen = max(0, sum[i] - ddl[j]);
//					if (dp[i ^ (1 << j)] + koufen < dp[i]) {
//						dp[i] = dp[i ^ (1 << j)] + koufen;
//						ans[i] = ans[i ^ (1 << j)] + name[j] + '\n';
//					}
//					else if ((dp[i ^ (1 << j)] + koufen == dp[i]) && ans[i] > ans[i ^ (1 << j)] + name[j] + '\n') {
//						ans[i] = ans[i ^ (1 << j)] + name[j] + '\n';
//					}
//				}
//			}
//		}
//		cout << dp[(1 << n) - 1] << endl;
//		cout << ans[(1 << n) - 1];
//	}
//}


////Catch that cow
//#include<iostream>
//#include<cstring>
//#include<queue>
//using namespace std;
//int N, K;
//const int MAXN = 100000;
//int visited[MAXN + 10];//判重标记，等于true表示已扩展
//struct Step {
//	int x;//位置
//	int steps;//到达x所需的步数
//	Step(int xx, int s) :x(xx), steps(s) {};//构造函数
//};
//queue<Step>q;//open表
//int main() {
//	cin >> N >> K;
//	memset(visited, 0, sizeof(visited));
//	q.push(Step(N, 0));//起始点
//	visited[N] = 1;
//	while (!q.empty()) {
//		Step s = q.front();
//		if (s.x == K) {
//			cout << s.steps << endl;
//			return 0;
//		}
//		else {
//			//按照题目，朝左右走
//			if (s.x - 1 >= 0 && !visited[s.x - 1]) {
//				q.push(Step(s.x - 1, s.steps + 1));//扩展下一个节点进入队列
//				visited[s.x - 1] = 1;//
//			}
//			if (s.x + 1 <=MAXN && !visited[s.x + 1]) {
//				q.push(Step(s.x + 1, s.steps + 1));
//				visited[s.x + 1] = 1;
//			}
//			if (s.x * 2 <= MAXN && !visited[s.x * 2]) {
//				q.push(Step(s.x * 2, s.steps + 1));
//				visited[s.x * 2] = 1;
//			}
//			q.pop();//顶部已经访问过
//		}
//	}
//}

//dfs:
////城堡问题
//#include<iostream>
//#include<stack>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int R, C;
//int maxRoomArea = 0;
//int roomNum = 0;
//int roomArea;//每次开始的时候都重新计数
//int color[60][60];
//int room[60][60];
//void dfs(int i, int k) {
//	if (color[i][k])
//		return;
//	roomArea++;
//	color[i][k] = roomNum;//这个还得判断在界内吧，显然是有超界风险了
//	if ((room[i][k] & 1) == 0)dfs(i, k - 1);
//	if ((room[i][k] & 2) == 0)dfs(i - 1, k);
//	if ((room[i][k] & 4) == 0)dfs(i, k + 1);
//	if ((room[i][k] & 8) == 0)dfs(i + 1, k);
//}
////用栈实现
//void Dfs(int r, int c) {
//	struct Room { int r; int c; Room(int rr, int cc) :r(rr), c(cc) {} };
//	stack<Room> stk;//用栈实现的时候是搭配结构体进行的，其实dfs也是这样，因为栈内储存的是状态/问题
//	stk.push(Room(r, c));
//	while (!stk.empty()) {
//		Room rm = stk.top();
//		int i = rm.r; int j = rm.c;
//		if (color[i][j])stk.pop();
//		else {
//			++roomArea;
//			color[i][j] = roomNum;
//			if ((room[i][j] & 1) == 0)stk.push(Room(i, j - 1));
//			if ((room[i][j] & 2) == 0)stk.push(Room(i - 1, j));
//			if ((room[i][j] & 4) == 0)stk.push(Room(i, j + 1));
//			if ((room[i][j] & 8) == 0)stk.push(Room(i + 1, j));
//		}
//	}
//
//}
//int main() {
//	cin >> R >> C;
//	for (int i = 1; i <= R; ++i) {
//		for (int k = 1; k <= C; ++k) {
//			cin >> room[i][k];
//		}
//	}
//	memset(color, 0, sizeof(color));
//	for (int i = 1; i <= R; ++i) {
//		for (int k = 1; k <= C; ++k) {
//			if (!color[i][k]) {
//				++roomNum;
//				roomArea = 0;
//				dfs(i, k);
//				maxRoomArea = max(roomArea, maxRoomArea);
//			}
//		}
//	}
//	cout << roomNum << endl;
//	cout << maxRoomArea << endl;
//}
//寻路问题
//#include<iostream>
//#include<vector>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int K, N, R, S, D, L, T;
//struct Road {
//	int d, L, t;
//};
//vector<vector<Road>>cityMap(110);//领接表，citymap[i]从i点有路连到的城市集合
//int minLen = 1 << 30;
//int totalLen;//正在走的路径长度
//int totalCost;//正在走的路径花销
//int visited[110];//城市是否走过的标记
//int minL[110][10100];//从1到i点，花费为j的最短路径
//void dfs(int s) {
//	if (s == N) {
//		minLen = min(minLen, totalLen);
//		return;
//	}
//	for (int i = 0; i < cityMap[s].size; ++i) {
//		int d = cityMap[s][i].d;
//		if (!visited[d]) {
//			int cost = totalCost + cityMap[s][i].t;
//			if (cost > K)continue;
//			if (totalLen + cityMap[s][i].L >= minLen || totalLen + cityMap[s][i].L >= minL[d][cost])continue;
//			totalLen += cityMap[s][i].L;
//			totalCost += cityMap[s][i].t;
//			minL[d][cost] = totalLen;
//			visited[d] = 1;
//			dfs(d);
//			visited[d] = 0;
//			totalCost -= cityMap[s][i].t;
//			totalLen -= cityMap[s][i].L;
//		}
//	}
//}
//int main() {
//	cin >> K >> N >> R;
//	for (int i = 0; i < R; ++i) {
//		int s;
//		Road r;
//		cin >> s >> r.d >> r.L >> r.t;
//		if (s != r.d)cityMap[s].push_back(r);
//	}
//	for (int i = 0; i < 110; ++i) {
//		for (int j = 0; j < 10100; ++j) {
//			minL[i][j] = 1 << 30;
//		}
//	}
//	memset(visited, 0, sizeof(visited));
//	totalLen = 0; totalCost = 0;
//	visited[1] = 1;
//	minLen = 1 << 30;
//	dfs(1);
//	if (minLen < (1 << 30))
//		cout << minLen << endl;
//	else {
//		cout << -1 << endl;
//	}
//}

//拯救少林神棍
//#include<iostream>
//#include<memory.h>
//#include<stdlib.h>
//#include<vector>
//#include<algorithm>
//using namespace std;
//int N;
//int L;
//vector<int>anLength;
//int anUsed[65];//是否用过的标记
//int j, i, k;
//int nLastStickNo;
//int Dfs(int R, int M) {
//	if (R == 0 && M == 0)return true;
//	if (M == 0)
//		M = L;//一根拼完，拼另一根,实际这样的接续拼是通过R指标体现的
//	int nStartNo = 0;
//	if (M != L)
//		nStartNo = nLastStickNo+1;
//	for (int i = nStartNo; i < N; ++i) {
//		if (!anUsed[i] && anLength[i] <= M) {
//			if (i > 0) {
//				if (anUsed[i - 1] == 0 && anLength[i] == anLength[i - 1])//相同长度，用前一个相同长度的是否用到来实现
//					continue;
//			}
//			anUsed[i] = 1; nLastStickNo = i;
//			if (Dfs(R - 1, M - anLength[i]))
//				return true;
//			else {
//			anUsed[i] = 0;//回溯，不用此棒
//			if (M == L||anLength[i]==L)//后悔不用此棒，结果发现这个木棒恰为第一根木棒，，直接剪枝，缺的是L，不用再试下一个了
//				return false;
//			}
//		}
//	}
//	return false;
//}
//int main() {
//	while (1) {
//		cin >> N;
//		if (N == 0)break;
//		int nTotalLen = 0;
//		anLength.clear();
//		for (int i = 0; i < N; i++) {
//			int n;
//			cin >> n;
//			anLength.push_back(n);
//			nTotalLen += anLength[i];
//		}
//		sort(anLength.begin(), anLength.end(), greater<int>());
//		//先排序记得！！
//		for (L = anLength[0]; L <= nTotalLen / 2; L++) {
//			if (nTotalLen%L)continue;
//			memset(anUsed, 0, sizeof(anUsed));
//			if (Dfs(N, L)) {//哪来的s，应该是N吧
//				cout << L << endl;
//			}
//		}
//		if (L > nTotalLen / 2) {
//			cout << nTotalLen << endl;
//		}
//
//	}
//}
//
//
////dfs作业：迷宫
//#include<iostream>
//#include<cstring>
//#include<algorithm>
//using namespace std;
//int cx[4] = { 0,1,0,-1 };
//
//int cy[4] = { 1,0,-1,0 };
////竟然还会随着cx,cy的组合而变化？
//inline bool valid(int i, int k) {
//	return (i <= 5) && (i >= 1) && (k <= 5) && (i >= 1);
//}
//int minLen = 1 << 30;
//int len;
//bool visited[7][7] = { {false} };
//int maze[7][7] = { {0} };
////
////添加记录路径的dfs
//pair<int, int>path[9];
//bool dfs(pair<int, int>x, int depth) {
//	if (x == make_pair(5, 5)) {
//		path[depth] = x;
//		return true;
//	}
//	if (visited[x.first][x.second]) {
//		return false;
//	}//增加了深度指标，所以不用回溯
//	visited[x.first][x.second] = true;
//	for (int i = 0; i < 4; i++) {
//		int xx = x.first + cx[i]; int yy = x.second + cy[i];
//		if (valid(xx,yy)&&maze[xx][yy]&& dfs({ xx,yy }, depth + 1)) {
//			//为什么maze[xx][yy]==0不行？
//			path[depth] = x;
//			return true;
//		}
//	}
//	return false;
//}
//void dfs(int x, int y) {//(1,1)到(5,5,)其实应该返回int是不是会比较好
//	if (x == 5 && y == 5) {
//		minLen = min(len, minLen);
//		return;
//	}
//	for (int i = 0; i < 4; i++) {
//		int xx = x + cx[i]; int yy = y + cy[i];
//		if (valid(xx, yy) && !visited[xx][yy]&&maze[xx][yy]==0) {
//			visited[xx][yy] = 1;
//			++len;
//			dfs(xx, yy);
//			--len;
//			visited[xx][yy] = 0;
//		}
//	}
//}
//int main() {
//	len = 1;
//
//	for (int i = 1; i <= 5; i++) {
//		for (int j = 1; j <= 5;j++) {
//			cin >> maze[i][j];
//			maze[i][j] = 1 - maze[i][j];
//		}
//	}
//	dfs({ 1,1 },0);
//	for (int i = 0; i < 7; i++) {
//		for (int j = 0; j < 7; j++) {
//			cout << maze[i][j] << " ";
//		}
//		cout << endl;
//	}
//	for (auto i : path) {
//		//cout << "(" << i.first - 1 << ", " << i.second - 1 << ")" << endl;
//		cout << '(' << i.first - 1 << ", " << i.second - 1 << ')' << endl;
//	}
//}
//

//#include <iostream>
//using namespace std;
//
//int a[7][7] = { {0} }, dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };
//bool vis[7][7] = { {false} };
//pair<int, int> path[9];
////要找路径dfs不能返回void，否则不知道这个点是不是在路径上
//bool dfs(pair<int, int> x, int depth) { //返回经过这个点是否能到终点，在dfs过程中记录到终点的路径
//	if (x == make_pair(5, 5)) { //到达终点
//		path[depth] = x;
//		return true;
//	}
//	if (vis[x.first][x.second])//旧点
//		return false;
//	vis[x.first][x.second] = true;//不用回溯
//	for (int i = 0; i < 4; i++) {
//		int xx = x.first + dx[i], yy = x.second + dy[i];
//		if (a[xx][yy] && dfs({ xx, yy }, depth + 1)) {//可行域并且往这里走能到终点
//			path[depth] = x;
//			return true;
//		}
//	}
//	return false;
//}
//int main() {
//	for (int i = 1; i <= 5; i++)
//		for (int j = 1; j <= 5; j++)
//			cin >> a[i][j], a[i][j] = 1 - a[i][j];//0是墙
//	dfs({ 1,1 }, 0);
//	for (auto i : path)
//		cout << '(' << i.first - 1 << ", " << i.second - 1 << ')' << endl;//', '要用双引号！！！
//}


//Pots:B题bfs
//#include <iostream>
//#include <queue>
//#include<string>
//using namespace std;
//
//struct info {
//	int a, b, t;
//	string ans;
//	info(int _a, int _b, int _t, string _ans) :a(_a), b(_b), t(_t), ans(_ans) {}
//};
//int main() {
//	int a, b, c;
//	cin >> a >> b >> c;
//	bool vis[101][101] = { {false} };
//	queue<info> q;
//	q.push({ 0,0,0,"" });
//	while (!q.empty()) {
//		info now = q.front();
//		q.pop();
//		if (vis[now.a][now.b])
//			continue;
//		else
//			vis[now.a][now.b] = true;
//		if (now.a == c || now.b == c) {
//			cout << now.t << endl << now.ans;
//			return 0;
//		}
//		q.push({ a,now.b,now.t + 1,now.ans + "FILL(1)\n" });
//		q.push({ now.a,b,now.t + 1,now.ans + "FILL(2)\n" });
//		q.push({ 0,now.b,now.t + 1,now.ans + "DROP(1)\n" });
//		q.push({ now.a,0,now.t + 1,now.ans + "DROP(2)\n" });
//		q.push({ (now.a > b - now.b ? now.a + now.b - b : 0),(now.a > b - now.b ? b : now.a + now.b),now.t + 1,now.ans + "POUR(1,2)\n" });
//		q.push({ (now.b > a - now.a ? a : now.a + now.b),(now.b > a - now.a ? now.a + now.b - a : 0),now.t + 1,now.ans + "POUR(2,1)\n" });
//	}
//	cout << "impossible\n";
//}
//
//#include<iostream>
//#include<queue>
//#include<string>
//using namespace std;
//struct pot {
//	int a, b, t;
//	string ans;
//	pot(int a_, int b_, int c_, string ans_) :a(a_), b(b_), t(c_), ans(ans_) {};
//
//};
//int main() {
//	int a, c, b;
//	cin >> a >> b >> c;
//	bool visited[101][101] = { {false} };
//	queue<pot>q;
//	q.push({ 0, 0, 0, "" });
//	while (!q.empty()) {
//		pot now = q.front();
//		q.pop();
//		if (visited[now.a][now.b])continue;
//		visited[now.a][now.b] = true;
//		if (now.a == c || now.b == c) {
//			cout << now.t << endl; cout << now.ans;
//			return 0;
//		}
//		q.push({ a,now.b,now.t + 1,now.ans + "FILL(1)\n" });
//		q.push({ now.a,b,now.t + 1,now.ans + "FILL(2)\n" });
//		q.push({ 0,now.b,now.t + 1,now.ans + "DROP(1)\n" });
//		q.push({ now.a,0,now.t + 1,now.ans + "DROP(2)\n" });
//		q.push({ (now.a > b - now.b ? now.a + now.b - b : 0),(now.a > b - now.b ? b : now.a + now.b),now.t + 1,now.ans + "POUR(1,2)\n" });
//		q.push({ (now.b > a - now.a ? a : now.a + now.b),(now.b > a - now.a ? now.a + now.b - a : 0),now.t + 1,now.ans + "POUR(2,1)\n" });
//	}
//	cout << "impossible\n";
//}

#include <iostream>
#include <cstring>
#include <string>
#include <queue>
#include <unordered_map>
using namespace std;

enum BLOCK { EMPTY = -3, WALL, SIFU, SNAKE };
struct node {
	int x, y, key, killed, t;//杀死的蛇用位运算存储
	node(int _x, int _y, int _key, int _killed, int _t) :x(_x), y(_y), key(_key), killed(_killed), t(_t) {}
};
bool vis[101][101][10][1 << 5] = { {false} };
int main() {
	int n, k;
	while (cin >> n >> k && n) {
		memset(vis, 0, sizeof(vis));
		int map[101][101] = { {0} }, dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 }, tmp_snakeID = 0, ans = 0x3f3f3f3f;
		unordered_map<int, int> coordinate_to_snakeID;//对蛇标号，方便看这个蛇死没死
		queue<node> q;//用优先队列反而更慢
		char tmp;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++) {
				cin >> tmp;
				if (tmp == '.') map[i][j] = EMPTY;//空格
				else if (tmp == '#') map[i][j] = WALL;//墙
				else if (tmp == 'T') map[i][j] = SIFU;//师傅
				else if (tmp == 'S')//蛇，给其一个编号
					map[i][j] = SNAKE, coordinate_to_snakeID[i * 100 + j] = tmp_snakeID++;
				else if (tmp == 'K')//孙悟空，初始化优先队列
					map[i][j] = EMPTY, q.push({ i,j,0,0,0 }), vis[i][j][0][0] = true;
				else map[i][j] = tmp - '0';//钥匙
			}
		while (!q.empty()) {
			node now = q.front();
			q.pop();
			for (int i = 0; i < 4; i++) {
				int xx = now.x + dx[i], yy = now.y + dy[i], keyy = now.key, killedd = now.killed, tt = now.t + 1;
				if (map[xx][yy] == WALL || vis[xx][yy][keyy][killedd] || xx < 1 || xx > n || yy < 1 || yy > n)//先排除不合法的状态
					continue;
				else if (map[xx][yy] == SIFU && keyy == k)//找到师傅，这个题比较复杂不能直接退出循环！！！
					ans = min(ans, tt);
				else if (map[xx][yy] == SNAKE && (!(killedd & (1 << coordinate_to_snakeID[xx * 100 + yy])))) //找到没杀死的蛇
					tt++, killedd |= (1 << coordinate_to_snakeID[xx * 100 + yy]);
				else if (map[xx][yy] == keyy + 1) //找到下一个钥匙
					keyy++;
				vis[xx][yy][keyy][killedd] = true;//别忘了维护vis数组！！！
				q.push({ xx,yy,keyy,killedd,tt });
			}
		}
		cout << (ans == 0x3f3f3f3f ? "impossible" : to_string(ans)) << endl;
	}
}